---
title: "Introduction to visiumStitched"
author: 
  - name: Nicholas J. Eagles
    affiliation:
    - &libd Lieber Institute for Brain Development
    email: nickeagles77@gmail.com
  - name: Leonardo Collado-Torres
    affiliation:
    - *libd
    - &ccb Center for Computational Biology, Johns Hopkins University
    - &jhubiostat Department of Biostatistics, Johns Hopkins Bloomberg School of Public Health
    email: lcolladotor@gmail.com
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('visiumStitched')`"
vignette: >
  %\VignetteIndexEntry{Introduction to visiumStitched}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
```


```{r vignetteSetup, echo=FALSE, message=FALSE, warning = FALSE}
## Track time spent on making the vignette
startTime <- Sys.time()

## Bib setup
library("RefManageR")

## Write bibliography information
bib <- c(
    R = citation(),
    BiocFileCache = citation("BiocFileCache")[1],
    BiocStyle = citation("BiocStyle")[1],
    dplyr = citation("dplyr")[1],
    ggplot2 = citation("ggplot2")[1],
    knitr = citation("knitr")[1],
    pkgcond = citation("pkgcond")[1],
    RefManageR = citation("RefManageR")[1],
    rmarkdown = citation("rmarkdown")[1],
    sessioninfo = citation("sessioninfo")[1],
    SpatialExperiment = citation("SpatialExperiment")[1],
    spatialLIBD = citation("spatialLIBD")[1],
    testthat = citation("testthat")[1],
    visiumStitched = citation("visiumStitched")[1]
)
```

# Basics

## Install `visiumStitched`

`r Biocpkg("visiumStitched")` is a `R` package available from [GitHub](https://github.com/LieberInstitute/visiumStitched).
It can be installed with the following commands in your `R` session:

```{r "install", eval = FALSE}
if (!requireNamespace("remotes", quietly = TRUE)) {
    install.packages("remotes")
}

remotes::install("LieberInstitute/visiumStitched")
```

## Citing `visiumStitched`

We hope that `r Biocpkg("visiumStitched")` will be useful for your research. Please use the following information to cite the package and the overall approach. Thank you!

```{r "citation"}
## Citation info
citation("visiumStitched")
```

## Packages used in this vignette

Let's load the packages we'll use in this vignette.

```{r "start", message=FALSE, warning=FALSE}
library("SpatialExperiment")
library("visiumStitched")
library("dplyr")
library("spatialLIBD")
library("BiocFileCache")
library("ggplot2")
```

# Preparing Experiment Information

Much of the `visiumStitched` package uses a `tibble` (or `data.frame`) defining information
about the experiment. Most fundamentally, the `group` column allows you to line up which
capture areas, in the `capture_area` column, are to be stitched together later. In our
case, we have just one unique group, consisting of all three capture areas. Note multiple
groups are supported. By the end of this demo, the `SpatialExperiment` will consist of
just one sample composed of the three capture areas; in general, there will be one sample
per group.

```{r "sample_info"}
## Create initial sample_info
sample_info <- tibble::tibble(
    group = "Br2719",
    capture_area = c("V13B23-283_A1", "V13B23-283_C1", "V13B23-283_D1")
)

## Initial sample_info
sample_info
```

Next, we'll need the Spaceranger outputs for each capture area, which can be retrieved
with `spatialLIBD::fetch_data()`.

```{r "spaceranger_dir"}
## Download example SpaceRanger output files
sr_dir <- tempdir()
temp <- unzip(spatialLIBD::fetch_data("visiumStitched_brain_spaceranger"),
    exdir = sr_dir)
sample_info$spaceranger_dir <- file.path(
    sr_dir, sample_info$capture_area, "outs", "spatial"
)

## Sample_info with paths to SpaceRanger output directories
sample_info
```

# Preparing Images for Fiji

The `visiumStitched` workflow makes use of [Fiji](https://imagej.net/software/fiji/), a
distribution of the `ImageJ` image-processing software, which includes an interface for
aligning images on a shared coordinate system. Before aligning anything in Fiji, we need to
ensure that images to align from all capture areas 
are on the same scale-- that is, a pixel in each image represents the same distance. This is
typically approximately true, but is not guaranteed to be exactly true, especially when the
capture areas to align come from different Visium slides. `rescale_fiji_inputs()` reads in the
[high-resolution tissue images](https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/spatial-outputs#tissue-png)
for each capture area, and uses info about their spot diameters in pixels and scale factors to
rescale the images appropriately (even if they are from different Visium slides).

For demonstration purposes, we'll set `out_dir` to a temporary location. Typically, it would
really be any suitable directory to place the rescaled images for later input to Fiji.

```{r "rescale_inputs"}
#   Generate rescaled approximately high-resolution images
sample_info <- rescale_fiji_inputs(sample_info, out_dir = tempdir())

## Sample_info with output directories
sample_info
```

# Building a `SpatialExperiment`

Before building a `SpatialExperiment` for a stitched dataset, we must align the images for each
group in Fiji. Check out [this video](https://www.youtube.com/watch?v=kFLtpK3qbSY) for a
guide through this process with the example data.

<iframe width="560" height="315" src="https://www.youtube.com/embed/kFLtpK3qbSY?si=CF-rv7Nd5yc7W6nC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Parsing Outputs from Fiji

From the Fiji alignment, two output files will be produced: an `XML` file specifying rigid
affine transformations for each
capture area, and the stitched approximately high-resolution image. These files for this
dataset are
available through `spatialLIBD::fetch_data()`. We'll need to add the paths to the XML
and PNG files to the `fiji_xml_path` and `fiji_image_path` columns of `sample_info`,
respectively.

```{r "fiji_out"}
fiji_dir <- tempdir()
temp <- unzip(fetch_data("visiumStitched_brain_Fiji_out"), exdir = fiji_dir)
sample_info$fiji_xml_path <- temp[grep("xml$", temp)]
sample_info$fiji_image_path <- temp[grep("png$", temp)]
```

We now have every column present in `sample_info` that will be necessary for any
`visiumStitched` function.

```{r "print_info"}
## Complete sample_info
sample_info
```

Before building the `SpatialExperiment`, the idea is to create a directory structure very similar to
[Spaceranger's spatial outputs](https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/spatial-outputs)
for each *group*, as opposed to the *capture-area*-level directories we already have. We'll
place this directory in a temporary location that will later be read in to produce the
final `SpatialExperiment`.

First, `prep_fiji_coords()` will apply the rigid affine transformations specified by Fiji's
output XML file to the spatial coordinates, ultimately producing a group-level `tissue_positions.csv` file.
Next, `prep_fiji_image()` will rescale the stitched image to have a default of 1,200 pixels in the longest dimension. The idea is that in an experiment with multiple groups, the images
stored in the `SpatialExperiment` for any group will be similarly scaled and occupy similar
memory footprints.

```{r "prep_fiji"}
## Prepare the Fiji coordinates and images.
## These functions return the file paths to the newly-created files that follow
## the standard directory structure from SpaceRanger (10x Genomics)
spe_input_dir <- tempdir()
prep_fiji_coords(sample_info, out_dir = spe_input_dir)
prep_fiji_image(sample_info, out_dir = spe_input_dir)
```

## Constructing the Object

We now have all the pieces to create the `SpatialExperiment` object. After constructing the
base object, information related to how spots may overlap between capture
areas in each `group` is added. The `sum_umi` metric will by default determine which
spots in overlapping regions to exclude in
plots. In particular, at regions of overlap, spots from capture areas with higher
average UMI (unique molecular identifier) counts will be plotted, while any other
spots will not be shown using `spatialLIBD::vis_clus()`, `spatialLIBD::vis_gene()`, and related visualization functions. We'll also mirror the image and gene-expression data to
match the orientation specified at the wet bench. More info about performing geometric
transformations is [here](#geometric-transformations).

```{r "gtf"}
## Download the Gencode v32 GTF file which is the closest one to the one
## that was used with SpaceRanger. Note that SpaceRanger GTFs are available at
## https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-GRCh38-2024-A.tar.gz
## but is too large for us to download here since it includes many other files
## we don't need right now.
## However, ideally you would adapt this code and use the actual GTF file you
## used when running SpaceRanger.
bfc <- BiocFileCache::BiocFileCache()
gtf_cache <- bfcrpath(
    bfc,
    paste0(
        "ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/",
        "release_32/gencode.v32.annotation.gtf.gz"
    )
)
```

```{r "build_spe"}
## Now we can build the SpatialExperiment object
spe <- build_spe(
    sample_info,
    coords_dir = spe_input_dir, reference_gtf = gtf_cache
)

## The images in this example data have to be mirrored across the horizontal axis.
spe <- SpatialExperiment::mirrorObject(spe, axis = "h")
```

The `exclude_overlapping` `colData()` column controls
which spots to drop for visualization purposes. Note also that the `overlap_key`
column was added, which gives a comma-separated string of spot keys overlapping each
given spot, or the empty string otherwise. This vignette won't cover the potential uses
of this information, but one possibility is to perform clustering and check how frequently
overlapping spots are assigned the same cluster.

```{r "exclude_overlapping"}
table(spe$exclude_overlapping)
```

# Examining the stitched data

## Stitched plotting

To demonstrate that we've stitched both the gene expression and image data successfully,
we'll use `spatialLIBD::vis_gene(is_stitched = TRUE)` to plot the distribution of white matter
spatially. Note that we're plotting raw counts; prior to normalization, library-size
variation across spots can bias the apparent distribution. Later, we'll show that
normalization is critical to producing a visually seamless transition between overlapping
capture areas.

```{r "explore_coords", fig.height = 4}
wm_genes <- rownames(spe)[
    match(c("MBP", "GFAP", "PLP1", "AQP4"), rowData(spe)$gene_name)
]
vis_gene(spe, geneid = wm_genes, assayname = "counts", is_stitched = TRUE)
```

## Array coordinates

Note also that the array coordinates (i.e. `spe$array_row` and `spe$array_col`) have been
recomputed to more sensibly index the stitched data. By definition, these array coordinates
(see [documentation from 10X](https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/spatial-outputs#tissue-positions))
are integer indices of each spot on a Visium capture area, numbering the typically 78 and 128
rows and columns, respectively, for a 6.5mm capture area. The `build_spe()` function retains
each capture area's original array coordinates, `spe$array_row_original` and `spe$array_col_original`,
but these are typically not useful to represent our group-level, stitched data. In fact, each 
stitched capture area has the same exact array coordinates, despite having different spatial
positions after stitching. We'll take in-tissue spots only and use transparency to emphasize
the overlap among capture areas:

```{r "array_plot_orig"}
colData(spe) |>
    as_tibble() |>
    filter(in_tissue) |>
    ggplot(
        mapping = aes(
            x = array_row_original, y = array_col_original, color = capture_area
        )
    ) +
    geom_point(alpha = 0.3) +
    coord_fixed()
```

Let's contrast this with the array coordinates recomputed by `visiumStitched`.
Briefly, `visiumStitched` forms a new hexagonal, Visium-like grid spanning the space occupied
by all capture areas after stitching. Then, the true spot positions are fit to the nearest new
spot positions, in terms of Euclidean distance. Finally, array coordinates are re-indexed
according to the new spot assignments, resulting in spatially meaningful values that apply at
the group level for stitched data. This ultimately enables downstream applications that use
the array coordinates, like
clustering with `BayesSpace` or `PRECAST`, to treat each group as a spatially continuous
sample.

```{r "array_plot_after"}
colData(spe) |>
    as_tibble() |>
    filter(in_tissue) |>
    ggplot(
        mapping = aes(
            x = array_row, y = array_col, color = capture_area
        )
    ) +
    geom_point(alpha = 0.3) +
    coord_fixed()
```

## Geometric transformations

As a `SpatialExperiment`, the stitched data may be rotated or mirrored by group, such as with
the `SpatialExperiment::rotateObject()` or `SpatialExperiment::mirrorObject()` functions.

```{r "rotate", fig.height=4}
vis_gene(
    rotateObject(spe, sample_id = "Br2719", degrees = 180),
    geneid = wm_genes, assayname = "counts", is_stitched = TRUE
)
```

```{r "mirror", fig.height = 4}
vis_gene(
    mirrorObject(spe, sample_id = "Br2719", axis = "v"),
    geneid = wm_genes, assayname = "counts", is_stitched = TRUE
)
```

## A note on normalization

As noted above, library-size variation across spots can bias the apparent spatial
distribution of genes when raw counts are used. The effect is often dramatic
enough that spatial trends cannot be easily seen across the stitched data until
data is log-normalized. Instead of performing normalization here, we'll fetch the
object with [normalized](https://bioconductor.org/books/3.12/OSCA/normalization.html#normalization-by-deconvolution)
counts from `spatialLIBD`, then plot a few white matter genes as before:

```{r "fetch_norm", fig.height = 4}
spe_norm <- fetch_data(type = "visiumStitched_brain_spe")

wm_genes_ens <- rownames(spe_norm)[
    match(c("MBP", "GFAP", "PLP1", "AQP4"), rowData(spe_norm)$gene_name)
]

vis_gene(
    spe_norm,
    geneid = wm_genes_ens, assayname = "logcounts", is_stitched = TRUE
)
```

Recall the unnormalized version of this plot, which is not nearly as clean:

```{r "unnorm_plot", fig.height = 4}
vis_gene(
    spe,
    geneid = wm_genes, assayname = "counts", is_stitched = TRUE
)
```

# Downstream applications

One common area of analysis in spatial transcriptomics involves clustering--
in particular, spatially aware clustering. Many spatially aware clustering
algorithms check the array coordinates to determine
neighboring spots and ultimately produce spatially smooth clusters. Since
`visiumStitched` [re-computes array coordinates](#array-coordinates) in a meaningful way,
software like [BayesSpace](https://doi.org/10.1038/s41587-021-00935-2) and
[PRECAST](https://doi.org/10.1038/s41467-023-35947-w) work out-of-the-box with
stitched data, treating each group as a single continuous sample.

[We've already run PRECAST](https://github.com/LieberInstitute/visiumStitched_brain/blob/devel/code/03_stitching/03_precast.R),
and can visualize the results here, where we see a fairly seamless transition of
cluster assignments across capture-area boundaries. First, let's examine `k = 2`:

```{r "precast_k2", fig.height = 4}
vis_clus(spe_norm, clustervar = "precast_k2", is_stitched = TRUE)
```

`k = 4` has also been computed:

```{r "precast_k4", fig.height = 4}
vis_clus(spe_norm, clustervar = "precast_k4", is_stitched = TRUE)
```

# Conclusion

`visiumStitched` provides a set of helper functions, in conjunction with ImageJ/Fiji,
intended to simplify the stitching of Visium data into a spatially integrated
`SpatialExperiment` object ready for analysis. We hope you find it useful for your
research!

# Reproducibility

The `r Biocpkg("visiumStitched")` package `r Citep(bib[["visiumStitched"]])` was made possible thanks to:

* R `r Citep(bib[["R"]])`
* `r Biocpkg("BiocFileCache")` `r Citep(bib[["BiocFileCache"]])`
* `r Biocpkg("BiocStyle")` `r Citep(bib[["BiocStyle"]])`
* `r CRANpkg("dplyr")` `r Citep(bib[["dplyr"]])`
* `r CRANpkg("ggplot2")` `r Citep(bib[["ggplot2"]])`
* `r CRANpkg("knitr")` `r Citep(bib[["knitr"]])`
* `r CRANpkg("pkgcond")` `r Citep(bib[["pkgcond"]])`
* `r CRANpkg("RefManageR")` `r Citep(bib[["RefManageR"]])`
* `r CRANpkg("rmarkdown")` `r Citep(bib[["rmarkdown"]])`
* `r CRANpkg("sessioninfo")` `r Citep(bib[["sessioninfo"]])`
* `r Biocpkg("SpatialExperiment")` `r Citep(bib[["SpatialExperiment"]])`
* `r Biocpkg("spatialLIBD")` `r Citep(bib[["spatialLIBD"]])`
* `r CRANpkg("testthat")` `r Citep(bib[["testthat"]])`

This package was developed using `r BiocStyle::Biocpkg("biocthis")`.

Code for creating the vignette

```{r createVignette, eval=FALSE}
## Create the vignette
library("rmarkdown")
system.time(render("visiumStitched.Rmd", "BiocStyle::html_document"))

## Extract the R code
library("knitr")
knit("visiumStitched.Rmd", tangle = TRUE)
```

Date the vignette was generated.

```{r reproduce1, echo=FALSE}
## Date the vignette was generated
Sys.time()
```

Wallclock time spent generating the vignette.

```{r reproduce2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits = 3)
```

`R` session information.

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```

# Bibliography

This vignette was generated using `r Biocpkg("BiocStyle")` `r Citep(bib[["BiocStyle"]])`
with `r CRANpkg("knitr")` `r Citep(bib[["knitr"]])` and `r CRANpkg("rmarkdown")` `r Citep(bib[["rmarkdown"]])` running behind the scenes.

Citations made with `r CRANpkg("RefManageR")` `r Citep(bib[["RefManageR"]])`.

```{r vignetteBiblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```
