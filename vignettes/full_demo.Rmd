---
title: "Introduction to visiumStitched"
author: 
  - name: Nicholas J. Eagles
    affiliation:
    - &libd Lieber Institute for Brain Development
    email: nickeagles77@gmail.com
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('visiumStitched')`"
vignette: >
  %\VignetteIndexEntry{Stitching a Visium Experiment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
```


```{r vignetteSetup, echo=FALSE, message=FALSE, warning = FALSE}
## Track time spent on making the vignette
startTime <- Sys.time()

## Bib setup
library("RefManageR")

## Write bibliography information
bib <- c(
    R = citation(),
    BiocStyle = citation("BiocStyle")[1],
    knitr = citation("knitr")[1],
    Matrix = citation("Matrix")[1],
    RefManageR = citation("RefManageR")[1],
    rmarkdown = citation("rmarkdown")[1],
    sessioninfo = citation("sessioninfo")[1],
    SpatialExperiment = citation('SpatialExperiment')[1],
    tidyverse = citation('tidyverse')[1],
    visiumStitched = citation("visiumStitched")[1]
)
```

```{r "start", message=FALSE}
library(SpatialExperiment)
library(visiumStitched)
library(tidyverse)
library(Matrix)
```

# Preparing Images for Fiji

Before aligning anything in Fiji, we need to ensure the image of each capture area to align
is on the same scale-- that is, a pixel in each image represents the same distance. This is
typically approximately true, but is not guaranteed to be exactly true, especially when the
capture areas to align come from different slides. `rescale_imagej_inputs()` reads in the
[high-resolution tissue images](https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/spatial-outputs#tissue-png)
for each capture area, and uses info about their spot diameters in pixels and scale factors to
rescale the images appropriately.

TODO: note about setting group and things being rescaled by group

For demonstration purposes, we'll set `out_dir` to a temporary location. Typically, it would
really be any suitable directory to place the rescaled images for later input to Fiji.

```{r "rescale_inputs", eval = FALSE}
#   Generate rescaled approximately high-resolution images 
rescale_imagej_inputs(sample_info, out_dir = tempdir())
```

# Building a `SpatialExperiment`

## Parsing Outputs from Fiji

While the alignment process in Fiji can't be part of this vignette, we can use the actual
outputs for this dataset: an XML file specifying rigid affine transformations for each
capture area, and the stitched approximately high-resolution image.

Before building the `SpatialExperiment`, the idea is to create a directory very similar to
[Spaceranger's spatial outputs](https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/spatial-outputs)
for each *group*, as opposed to the *capture-area*-level directories we already have. We'll
place this directory in a temporary location that will later be read in to produce the
final `SpatialExperiment`.

First, `prep_imagej_coords()` will apply the rigid affine transformations specified by Fiji's
output XML file to the spatial coordinates, ultimately producing a group-level `tissue_positions.csv` file.
Next, `prep_imagej_image()` will rescale the stitched image to have a default of 1200 pixels
in its larger dimension. The idea is that in an experiment with multiple groups, the images
stored in the `SpatialExperiment` for any group will be similarly scaled and occupy similar
memory footprints.

```{r "prep_imagej", eval = FALSE}
spe_input_dir = tempdir()
prep_imagej_coords(sample_info, out_dir = spe_input_dir)
prep_imagej_image(sample_info, out_dir = spe_input_dir)
```

## Constructing the Object

We now have all the pieces to create the `SpatialExperiment`. After constructing the
base object, we'll add information related to how spots may overlap between capture
areas in each group. We'll compute the `sum_umi` metric, which will be passed to
`add_overlap_info()` to determine which spots in overlapping regions to exclude in
plots. In particular, at regions of overlap, spots from capture areas with higher
average UMI (unique molecular identifier) counts will be plotted, while any other
spots will be dropped for visualization purposes.

```{r "build_spe", eval = FALSE}
spe = build_spe(sample_info, coords_dir = spe_input_dir)

spe$sum_umi = colSums(assays(spe)$counts)
spe = add_overlap_info(spe, "sum_umi")
```

The `exclude_overlapping` `colData()` column added by `add_overlap_info()` controls
which spots to drop for visualization purposes. Note also that the `overlap_key`
column was added, which gives a comma-separated string of spot keys overlapping each
given spot, or the empty string otherwise. This vignette won't cover the potential uses
of this information, but one possibility is to perform clustering and check how frequently
overlapping spots are assigned the same cluster.

```{r "exclude_overlapping", eval = FALSE}
table(spe$exclude_overlapping)
```

# Examining the stitched data

## Stitched plotting

To demonstrate that we've stitched both the gene expression and image data successfully,
we'll use `spatialLIBD::vis_gene(is_stitched = TRUE)` to plot the distribution of white matter
spatially. Note that we're plotting raw counts; prior to normalization, library-size
variation across spots can bias the apparent distribution. Later, we'll show that
normalization is critical to producing a visually seamless transition between overlapping
capture areas.

```{r "explore_coords", eval = FALSE}
wm_genes = rownames(spe)[
    match(c("MBP", "GFAP", "PLP1", "AQP4"), rowData(spe)$symbol)
]
vis_gene(spe, geneid = wm_genes, assayname = 'counts', is_stitched = TRUE)
```

## Array coordinates

Note also that the array coordinates (i.e. `spe$array_row` and `spe$array_col`) have been
recomputed to more sensibly index the stitched data. By definition, these array coordinates
(see [documentation from 10X](https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/spatial-outputs#tissue-positions))
are integer indices of each spot on a Visium capture area, numbering the typically 78 and 128
rows and columns, respectively, for a 6.5mm capture area. The `build_spe()` function retains
each capture area's original array coordinates, `spe$array_row_original` and `spe$array_col_original`,
but these are typically not useful to represent our group-level, stitched data. In fact, each 
stitched capture area has the same exact array coordinates, despite having different spatial
positions after stitching. We'll take in-tissue spots only and use transparency to emphasize
the overlap among capture areas:

```{r "array_plot_orig", eval = FALSE}
colData(spe) |>
    as_tibble() |>
    filter(in_tissue) |>
    ggplot(
        mapping = aes(
            x = array_row_original, y = array_col_original, color = capture_area
        )
    ) +
        geom_point(alpha = 0.3)
```

Let's contrast this with the array coordinates recomputed by `visiumStitched`.
Briefly, `visiumStitched` forms a new hexagonal, Visium-like grid spanning the space occupied
by all capture areas after stitching. Then, the true spot positions are fit to the nearest new
spot positions, in terms of Euclidean distance. Finally, array coordinates are re-indexed
according to the new spot assignments, resulting in spatially meaningful values that apply at
the group level for stitched data. This ultimately enables downstream applications that use
the array coordinates, like
clustering with `BayesSpace` or `PRECAST`, to treat each group as a spatially continuous
sample.

```{r "array_plot_orig", eval = FALSE}
colData(spe) |>
    as_tibble() |>
    filter(in_tissue) |>
    ggplot(
        mapping = aes(
            x = array_row, y = array_col, color = capture_area
        )
    ) +
        geom_point(alpha = 0.3)
```

## Geometric transformations

As a `SpatialExperiment`, the stitched data may be rotated or mirrored by group, such as with
the `SpatialExperiment::rotateObject()` or `SpatialExperiment::mirrorObject()` functions.

```{r "rotate", eval = FALSE}
vis_gene(
    rotateObject(spe, sample_id = 'Br2719', degrees = 90),
    geneid = wm_genes, assayname = 'counts', is_stitched = TRUE
)
```

```{r "mirror", eval = FALSE}
vis_gene(
    mirrorObject(spe, sample_id = 'Br2719', axis = "v"),
    geneid = wm_genes, assayname = 'counts', is_stitched = TRUE
)
```

## A note on normalization

As noted above, library-size variation across spots can bias the apparent spatial
distribution of genes when raw counts are used. The effect is often dramatic
enough that spatial trends cannot be easily seen across the stitched data until
data is log-normalized. Instead of performing normalization here, we'll fetch the
object with [normalized](https://bioconductor.org/books/3.12/OSCA/normalization.html#normalization-by-deconvolution)
counts from `spatialLIBD`, then plot a few white matter genes as before:

```{r "fetch_norm", eval = FALSE}
spe_norm = fetch_data(type = 'Visium_LS_spe')

vis_gene(
    spe_norm, geneid = wm_genes, assayname = 'logcounts', is_stitched = TRUE
)
```

Recall the unnormalized version of this plot, which is not nearly as clean:

```{r "unnorm_plot", eval = FALSE}
vis_gene(
    spe, geneid = wm_genes, assayname = 'logcounts', is_stitched = TRUE
)
```

# Conclusion

`visiumStitched` provides a set of helper functions, in conjunction with ImageJ/Fiji,
intended to simplify the stitching of Visium data into a spatially integrated
`SpatialExperiment` object ready for analysis. We hope you find it useful for your
research!

# Reproducibility

Code for creating the vignette

```{r createVignette, eval=FALSE}
## Create the vignette
library("rmarkdown")
system.time(render("full_demo.Rmd", "BiocStyle::html_document"))

## Extract the R code
library("knitr")
knit("full_demo.Rmd", tangle = TRUE)
```

Date the vignette was generated.

```{r reproduce1, echo=FALSE}
## Date the vignette was generated
Sys.time()
```

Wallclock time spent generating the vignette.

```{r reproduce2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits = 3)
```

`R` session information.

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```

# Bibliography

This vignette was generated using `r Biocpkg("BiocStyle")` `r Citep(bib[["BiocStyle"]])`
with `r CRANpkg("knitr")` `r Citep(bib[["knitr"]])` and `r CRANpkg("rmarkdown")` `r Citep(bib[["rmarkdown"]])` running behind the scenes.

Citations made with `r CRANpkg("RefManageR")` `r Citep(bib[["RefManageR"]])`.

```{r vignetteBiblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```
